<?php
/**
 * MUImage.
 *
 * @copyright Michael Ueberschaer
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package MUImage
 * @author Michael Ueberschaer <kontakt@webdesign-in-bremen.com>.
 * @link http://www.webdesign-in-bremen.com
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.4 (http://modulestudio.de) at Thu Feb 23 22:43:24 CET 2012.
 */

use Imagine\Gd\Imagine;
use Imagine\Image\Box;
use Imagine\Image\Point;
use Imagine\Image\ManipulatorInterface;

/**
 * This handler class handles the page events of the Form called by the MUImage_user_edit() function.
 * It aims on the picture object type.
 *
 * More documentation is provided in the parent class.
 */
class MUImage_Form_Handler_Picture_Base_ZipUpload extends MUImage_Form_Handler_Common_Edit
{
    /**
     * Pre-initialise hook.
     *
     * @return void
     */
    public function preInitialize()
    {
        parent::preInitialize();

        $this->objectType = 'picture';
        $this->objectTypeCapital = 'Picture';
        $this->objectTypeLower = 'picture';

        $this->hasPageLockSupport = true;
        $this->hasCategories = false;
        // array with upload fields and mandatory flags
        $this->uploadFields = array('zipUpload' => true);
        // array with list fields and multiple flags
        $this->listFields = array('workflowState' => false);
    }

    /**
     * Initialize form handler.
     *
     * This method takes care of all necessary initialisation of our data and form states.
     *
     * @return boolean False in case of initialization errors, otherwise true.
     */
    public function initialize(Zikula_Form_View $view)
    {
        parent::initialize($view);
         
        $dom = ZLanguage::getModuleDomain('MUImage');
         
        SessionUtil::delVar('muimagepictureids');

        $allowedFields = MUImage_Util_Controller::allowedFields();

        $zipSize = MUImage_Util_Controller::maxSize('zip');

        // we check for required width for pictures
        $minWidth = MUImage_Util_Controller::minWidth();
        // we check for maximum width for pictures
        $maxWidth = MUImage_Util_Controller::maxWidth();
        // we check for maximum height for pictures
        $maxHeight = MUImage_Util_Controller::maxHeight();
         
        $this->view->assign('zipSize', $zipSize);

        // everything okay, no initialization errors occured
        return true;
    }

    /**
     * Post-initialise hook.
     *
     * @return void
     */
    public function postInitialize()
    {
        parent::postInitialize();
    }

    /**
     * Get list of allowed redirect codes.
     */
    protected function getRedirectCodes()
    {
        // admin list of albums
        $codes[] = 'adminViewAlbum';
        // admin display page of treated album
        $codes[] = 'adminDisplayAlbum';
        // user list of albums
        $codes[] = 'userViewAlbum';
        // user display page of treated album
        $codes[] = 'userDisplayAlbum';
        return $codes;
    }

    /**
     * Get the default redirect url. Required if no returnTo parameter has been supplied.
     * This method is called in handleCommand so we know which command has been performed.
     */
    protected function getDefaultReturnUrl($args, $obj)
    {
        // redirect to the list of pictures
        $viewArgs = array('ot' => $this->objectType);
        $url = ModUtil::url($this->name, 'user', 'view', $viewArgs);

        if ($args['commandName'] != 'delete' && !($this->mode == 'create' && $args['commandName'] == 'cancel')) {
            // redirect to the detail page of treated picture
            $url = ModUtil::url($this->name, 'user', 'display', array('ot' => 'picture', 'id' => $this->idValues['id']));
        }
        return $url;
    }

    /**
     * Command event handler.
     *
     * This event handler is called when a command is issued by the user.
     */
    public function handleCommand(Zikula_Form_View $view, &$args)
    {
        $albumid = $this->request->getGet()->filter('album', 0, FILTER_SANITIZE_NUMBER_INT);
        $func = $this->request->query->filter('func', 'edit', FILTER_SANITIZE_STRING);

        if ($args['commandName'] == 'submit') {

            $entityClass = $this->name . '_Entity_' . ucfirst($this->objectType);
            $repository = $this->entityManager->getRepository($entityClass);

            // fetch posted data input values as an associative array
            $formData = $this->view->getValues();
            $entityData = $formData[$this->objectTypeLower];
            unset($formData[$this->objectTypeLower]);

            //$upload
            $entityData = $this->handleUploads($entityData, $entity);

            $uploadHandler = new MUImage_UploadHandler();

            $serviceManager = ServiceUtil::getManager();
            $controllerHelper = new MUImage_Util_Controller($serviceManager);

            $basePath = $controllerHelper->getFileBaseFolder('picture', 'imageUpload');

            $zip = new ZipArchive();
            $zip->open($basePath . $entityData['zipUpload']);
            $zipFileName = $entityData['zipUpload'];
            unset($entityData['zipUpload']);
            unset($entityData['zipUploadMeta']);

            for ($i = 0; $i < $zip->numFiles; $i++) {

                $name = $zip->getNameIndex($i);
                $fileNameParts = explode('.', $name);
                $extension = strtolower($fileNameParts[count($fileNameParts) - 1]);
                $allowedExtensions = array('gif', 'jpeg', 'jpg', 'png');
                if (count($allowedExtensions) > 0) {
                    if (!in_array($extension, $allowedExtensions)) {
                        continue;
                    }
                }

                $fileName = $uploadHandler->determineFileName('picture', 'imageUpload', $basePath, $name, $extension);

                $zip->renameIndex($i, $fileName);

                $entry = array($fileName);
                $zip->extractTo($basePath, $entry);

                $uploadHandler = new MUImage_UploadHandler();
                $metaData = $uploadHandler->readMetaDataForFile($fileName, $basePath . $fileName);

                if ($func == 'zipUpload') {
                    // retrieve the final file name
                    $fileNameParts = explode('.', $fileName);
                    $fileNamePartsWithoutExtension = array_slice($fileNameParts, 0, count($fileNameParts) - 1);
                    $fileNameWithoutExtension = implode('.', $fileNamePartsWithoutExtension);

                    $imagine = new Imagine();

                    // we create the thumnail
                    $widthFirst = ModUtil::getVar('MUImage', 'widthFirst');
                    $heightFirst = ModUtil::getVar('MUImage', 'heightFirst');
                    if ($widthFirst > 0 && $heightFirst > 0) {
                        $nameForThumb = $fileNameWithoutExtension . '_tmb.jpg';
                        $imagine->open($basePath . $fileName)->thumbnail(new Box($widthFirst, $heightFirst), 'inset')->save($basePath . $nameForThumb);
                    }
                    // we create the preview
                    $widthSecond = ModUtil::getVar('MUImage', 'widthSecond');
                    $heightSecond = ModUtil::getVar('MUImage', 'heightSecond');
                    if ($widthSecond > 0 && $heightSecond > 0) {
                        $nameForThumb = $fileNameWithoutExtension . '_pre.jpg';
                        $imagine->open($basePath . $fileName)->thumbnail(new Box($widthSecond, $heightSecond), 'inset')->save($basePath . $nameForThumb);
                    }
                    // we create the full image
                    $widthThird = ModUtil::getVar('MUImage', 'widthThird');
                    $heightThird = ModUtil::getVar('MUImage', 'heightThird');
                    if ($widthThird > 0 && $heightThird > 0) {
                        $nameForThumb = $fileNameWithoutExtension . '_full.jpg';
                        $imagine->open($basePath . $fileName)->thumbnail(new Box($widthThird, $heightThird), 'inset')->save($basePath . $nameForThumb);
                    }
                }

                if (!is_array($metaData)) {
                    continue;
                }

                $entity = new MUImage_Entity_Picture();
                // save the entered datas to the allowed upload field
                $entityData['imageUpload'] = $fileName;

                $entityData['imageUploadMeta'] = $metaData;

                // get the selected album as object
                $albumrepository = MUImage_Util_Model::getAlbumRepository();
                $album = $albumrepository->selectById($albumid);
                $entityData['Album'] = $album;

                // file name for title?
                $fileNameForTitle = ModUtil::getVar($this->name, 'fileNameForTitle');

                // set the file name as title
                if ($fileNameForTitle == true) {
                    $fileNameParts2 = explode('.', $fileName);
                    $entity->setTitle($this->__($fileNameParts2[count($fileNameParts2) - 2]));
                } else { // set a default title
                    $entity->setTitle($this->__('Please enter title...'));
                }

                // set the correct data for imageupload
                $entity->setImageUpload($entityData['imageUpload']);

                // set workflow state to approved
                $entity->setWorkflowState('approved');

                // assign fetched data
                $entity->merge($entityData);

                // save updated entity
                $this->entityRef = $entity;

                $this->performUpdate($args);

                $success = true;

                // default message
                $this->addDefaultMessage($args, $success);

            }
            $zip->close();
            unlink($basePath . $zipFileName);

            if ($fileNameForTitle == true) {
                $url = ModUtil::url($this->name, 'user', 'display', array('ot' => 'album', 'id' => $albumid));
                return System::redirect($url);
            }

            $pictureids = SessionUtil::getVar('muimagepictureids');
            $pictures = unserialize($pictureids);
            if ($pictures) {
                $id = $pictures[0];
                $url = ModUtil::url($this->name, 'picture', 'editMulti', array('ot' => 'picture', 'id' => $id, 'album' => $albumid));
            } else {
                $url = ModUtil::url($this->name, 'picture', 'multiUpload', array('ot' => 'picture', 'album' => $albumid));
            }
            return System::redirect($url);

        }
         
        if ($args['commandName'] == 'cancel') {
            $url = ModUtil::url($this->name, 'user', 'display', array('ot' => 'album', 'id' => $albumid));
            return $this->view->redirect($url);

        }
    }

    /**
     * Get success or error message for default operations.
     *
     * @param Array   $args    arguments from handleCommand method.
     * @param Boolean $success true if this is a success, false for default error.
     * @return String desired status or error message.
     */
    protected function getDefaultMessage($args, $success = false)
    {
        if ($success !== true) {
            return parent::getDefaultMessage($args, $success);
        }

        $message = '';
        switch ($args['commandName']) {
            case 'submit':
                $message = $this->__('Done! Picture uploaded.');
                break;
            case 'update':
                $message = $this->__('Done! Picture updated.');
                break;
            case 'delete':
                $message = $this->__('Done! Picture deleted.');
                break;
        }
        return $message;
    }

    /**
     * This method executes a certain workflow action.
     *
     * @param Array $args Arguments from handleCommand method.
     *
     * @return bool Whether everything worked well or not.
     */
    public function applyAction(array $args = array())
    {
        // get treated entity reference from persisted member var
        $entity = $this->entityRef;

        $action = $args['commandName'];

        try {
            // execute the workflow action
            $workflowHelper = new MUImage_Util_Workflow($this->view->getServiceManager());
            $success = $workflowHelper->executeAction($entity, $action);
        } catch(\Exception $e) {
            LogUtil::registerError($this->__f('Sorry, but an unknown error occured during the %s action. Please apply the changes again!', array($action)));
        }

        $this->addDefaultMessage($args, $success);

        if ($success && $this->mode == 'create') {
            // store new identifier
            foreach ($this->idFields as $idField) {
                $this->idValues[$idField] = $entity[$idField];
            }
        }


        return $success;
    }

    /**
     * Add success or error message to session.
     *
     * @param Array   $args    arguments from handleCommand method.
     * @param Boolean $success true if this is a success, false for default error.
     */
    /*protected function addDefaultMessage($args, $success = false)
     {
    $message = $this->getDefaultMessage($args, $success);
    if (!empty($message)) {
    if ($success === true) {
    LogUtil::registerStatus($message);
    } else {
    LogUtil::registerError($message);
    }
    }
    }

    /**
    * Input data processing called by handleCommand method.
    */
    /*public function fetchInputData(Zikula_Form_View $view, &$args)
     {

    // get treated entity reference from persisted member var
    $entity = $this->entityRef;

    $entityData = array();

    $this->reassignRelatedObjects();
    $entityData['Album'] = ((isset($selectedRelations['album'])) ? $selectedRelations['album'] : $this->retrieveRelatedObjects('album', 'muimageAlbum_AlbumItemList', false, 'POST'));

    // assign fetched data
    if (count($entityData) > 0) {
    $entity->merge($entityData);
    }

    // save updated entity
    $this->entityRef = $entity;
    }
    /**
    * Executing insert and update statements
    *
    * @param Array   $args    arguments from handleCommand method.
    */
    public function performUpdate($args)
    {
        // get treated entity reference from persisted member var
        $entity = $this->entityRef;

        $this->entityManager->persist($entity);
        $this->entityManager->flush();

    }

    /**
     * Get url to redirect to.
     *
     * @param array  $args List of arguments.
     *
     * @return string The redirect url.
     */
    protected function getRedirectUrl($args)
    {
        if ($this->inlineUsage == true) {
            $urlArgs = array('idPrefix'    => $this->idPrefix,
                    'commandName' => $args['commandName']);
            foreach ($this->idFields as $idField) {
                $urlArgs[$idField] = $this->idValues[$idField];
            }

            // inline usage, return to special function for closing the Zikula.UI.Window instance
            return ModUtil::url($this->name, FormUtil::getPassedValue('type', 'user', 'GETPOST'), 'handleInlineRedirect', $urlArgs);
        }

        if ($this->repeatCreateAction) {
            return $this->repeatReturnUrl;
        }

        // normal usage, compute return url from given redirect code
        if (!in_array($this->returnTo, $this->getRedirectCodes())) {
            // invalid return code, so return the default url
            return $this->getDefaultReturnUrl($args);
        }

        // parse given redirect code and return corresponding url
        switch ($this->returnTo) {
            case 'admin':
                return ModUtil::url($this->name, 'admin', 'main');
            case 'adminView':
                return ModUtil::url($this->name, 'admin', 'view', array('ot' => $this->objectType));
            case 'adminDisplay':
                if ($args['commandName'] != 'delete' && !($this->mode == 'create' && $args['commandName'] == 'cancel')) {
                    $urlArgs['ot'] = $this->objectType;
                    foreach ($this->idFields as $idField) {
                        $urlArgs[$idField] = $this->idValues[$idField];
                    }
                    return ModUtil::url($this->name, 'admin', 'display', $urlArgs);
                }
                return $this->getDefaultReturnUrl($args);
            case 'user':
                return ModUtil::url($this->name, 'user', 'main');
            case 'userView':
                return ModUtil::url($this->name, 'user', 'view', array('ot' => $this->objectType));
            case 'userDisplay':
                if ($args['commandName'] != 'delete' && !($this->mode == 'create' && $args['commandName'] == 'cancel')) {
                    $urlArgs['ot'] = $this->objectType;
                    foreach ($this->idFields as $idField) {
                        $urlArgs[$idField] = $this->idValues[$idField];
                    }
                    return ModUtil::url($this->name, 'user', 'display', $urlArgs);
                }
                return $this->getDefaultReturnUrl($args);
            case 'adminViewAlbum':
                return ModUtil::url($this->name, 'admin', 'view', array('ot' => 'album'));
            case 'adminDisplayAlbum':
                if (!empty($this->relationPresets['album'])) {
                    return ModUtil::url($this->name, 'admin', 'display', array('ot' => 'album', 'id' => $this->relationPresets['album']));
                }
                return $this->getDefaultReturnUrl($args);
            case 'userViewAlbum':
                return ModUtil::url($this->name, 'user', 'view', array('ot' => 'album'));
            case 'userDisplayAlbum':
                if (!empty($this->relationPresets['album'])) {
                    return ModUtil::url($this->name, 'user', 'display', array('ot' => 'album', 'id' => $this->relationPresets['album']));
                }
                return $this->getDefaultReturnUrl($args);
            default:
                return $this->getDefaultReturnUrl($args);
        }
    }


    /**
     * Reassign options chosen by the user to avoid unwanted form state resets.
     * Necessary until issue #23 is solved.
     */
    /*public function reassignRelatedObjects()
     {
    $selectedRelations = array();
    // reassign the album eventually chosen by the user
    $selectedRelations['album'] = $this->retrieveRelatedObjects('album', 'muimageAlbum_AlbumItemList', false, 'POST');
    $this->view->assign('selectedRelations', $selectedRelations);
    }

    /**
    * Helper method to process upload fields
    */
    protected function handleUploads($formData, $existingObject)
    {
        if (!count($this->uploadFields)) {
            return $formData;
        }

        // initialise the upload handler
        $uploadManager = new MUImage_UploadHandler();
        // $existingObjectData = $existingObject->toArray();

        // process all fields
        foreach ($this->uploadFields as $uploadField => $isMandatory) {
            // check if an existing file must be deleted
            /* $hasOldFile = (!empty($existingObjectData[$uploadField]));
             $hasBeenDeleted = !$hasOldFile;
            if ($this->mode != 'create') {
            if (isset($formData[$uploadField . 'DeleteFile'])) {
            if ($hasOldFile && $formData[$uploadField . 'DeleteFile'] === true) {
            // remove upload file (and image thumbnails)
            $existingObjectData = $uploadManager->deleteUploadFile($this->objectType, $existingObjectData, $uploadField);
            if (empty($existingObjectData[$uploadField])) {
            $existingObject[$uploadField] = '';
            }
            }
            unset($formData[$uploadField . 'DeleteFile']);
            $hasBeenDeleted = true;
            }
            }*/

            // look whether a file has been provided
            if (!$formData[$uploadField] || $formData[$uploadField]['size'] == 0) {
                // no file has been uploaded
                unset($formData[$uploadField]);
                // skip to next one
                continue;
            }

            if ($hasOldFile && $hasBeenDeleted !== true && $this->mode != 'create') {
                // remove old upload file (and image thumbnails)
                $existingObjectData = $uploadManager->deleteUploadFile($this->objectType, $existingObjectData, $uploadField);
                if (empty($existingObjectData[$uploadField])) {
                    $existingObject[$uploadField] = '';
                }
            }

            // do the actual upload (includes validation, physical file processing and reading meta data)
            $uploadResult = $uploadManager->performFileUpload($this->objectType, $formData, $uploadField);
            if ($uploadResult == false) {
                return false;
            }
            // assign the upload file name
            $formData[$uploadField] = $uploadResult['fileName'];
            // assign the meta data
            $formData[$uploadField . 'Meta'] = $uploadResult['metaData'];

            // if current field is mandatory check if everything has been done
            if ($isMandatory && $formData[$uploadField] === false) {
                // mandatory upload has not been completed successfully
                return false;
            }

            // upload succeeded
        }

        return $formData;
    }
}
