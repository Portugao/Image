<?php


/**
 * MUImage.
 *
 * @copyright Michael Ueberschaer
 * @license http://www.gnu.org/licenses/lgpl.html GNU Lesser General Public License
 * @package MUImage
 * @author Michael Ueberschaer <kontakt@webdesign-in-bremen.com>.
 * @link http://www.webdesign-in-bremen.com
 * @link http://zikula.org
 * @version Generated by ModuleStudio 0.5.4 (http://modulestudio.de) at Thu Feb 23 22:43:24 CET 2012.
 */

use Imagine\Gd\Imagine;
use Imagine\Image\Box;
use Imagine\Image\Point;
use Imagine\Image\ManipulatorInterface;

/**
 * Upload handler implementation class.
 */
class MUImage_UploadHandler extends MUImage_Base_UploadHandler
{

    /**
     * var array List of allowed file sizes per field.
     */
    protected $allowedFileSizes;

    /**
     * Constructor initialising the supported object types.
     */
    public function __construct()
    {
        $this->allowedObjectTypes = array('picture');
        $this->imageFileTypes = array('gif', 'jpeg', 'jpg', 'png');
        $this->forbiddenFileTypes = array('cgi', 'pl', 'asp', 'phtml', 'php', 'php3', 'php4', 'php5', 'exe', 'com', 'bat', 'jsp', 'cfm', 'shtml');
        //$this->allowedFileSizes = array('picture' => array('imageUpload' => $filesize));

    }

    /**
     * Process a file upload.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fileData   Form data array.
     * @param string $fieldName  Name of upload field.
     *
     * @return array Resulting file name and collected meta data.
     */
    public function performFileUpload($objectType, $fileData, $fieldName)
    {
        $dom = ZLanguage::getModuleDomain('MUImage');

        $result = array('fileName' => '',
                'metaData' => array());

        // check whether uploads are allowed for the given object type
        if (!in_array($objectType, $this->allowedObjectTypes)) {
            return $result;
        }

        // perform validation
        if (!$this->validateFileUpload($objectType, $fileData[$fieldName], $fieldName)) {
            // skip this upload field
            return $result;
        }

        // retrieve the final file name
        $fileName = $fileData[$fieldName]['name'];
        $fileNameParts = explode('.', $fileName);
        $extension = strtolower($fileNameParts[count($fileNameParts) - 1]);
        $extension = str_replace('jpeg', 'jpg', $extension);
        $fileNameParts[count($fileNameParts) - 1] = $extension;
        $fileName = implode('.', $fileNameParts);

        // we get the extension for later use
        $thisExtension = $extension;

        $serviceManager = ServiceUtil::getManager();
        $controllerHelper = new MUImage_Util_Controller($serviceManager);

        // retrieve the final file name
        try {
            $basePath = $controllerHelper->getFileBaseFolder($objectType, $fieldName);
        } catch (\Exception $e) {
            return LogUtil::registerError($e->getMessage());
        }
        $fileName = $this->determineFileName($objectType, $fieldName, $basePath, $fileName, $extension);

        if (!move_uploaded_file($fileData[$fieldName]['tmp_name'], $basePath . $fileName)) {
            return LogUtil::registerError(__('Error! Could not move your file to the destination folder.', $dom));
        }

        $maxWidth = ModUtil::getVar('MUImage', 'maxWidth');
        $maxHeight = ModUtil::getVar('MUImage', 'maxHeight');

        if (ModUtil::getVar('MUImage', 'shrinkPictures') == 1 && ($maxHeight > 0 && $maxHeight != '' && $maxHeight > 0 && $maxHeight != '')) {
            $imagine = new Imagine();
            $image = $imagine->open($basePath . $fileName);
            $size = $image->getSize();
            $imageWidth = $size->getWidth();
            $imageHeight = $size->getHeight();
            $ratio = $imageHeight / $imageWidth;
            $ratio = round($ratio, 2);
            if ($imageWidth >= $imageHeight) {
                if ($imageWidth > $maxWidth) {
                    $newWidth = $maxWidth;
                    $newHeight = $newWidth * $ratio;
                } else {
                    $newWidth = $imageWidth;
                    $newHeight = $imageHeight;
                }
            }
            if ($imageHeight > $imageWidth) {
                if ($imageHeight > $maxHeight) {
                    $newHeight = $maxHeight;
                    $newWidth = $newHeight / $ratio;
                } else {
                    $newHeight = $imageHeight;
                    $newWidth = $imageWidth;
                }
            }
            if ($newWidth != $imageWidth || $newHeight != $imageHeight) {
                $image->resize(new Box($newWidth, $newHeight));
                //$image->crop(new Point(0, 0), new Box($newWidth, $newHeight));
                $image->save($basePath . $fileName);
            }
        } else {

            // retrieve the final file name

            $fileNameParts = explode('.', $fileName);
            $fileNamePartsWithoutExtension = array_slice($fileNameParts, 0, count($fileNameParts) - 1);
            $fileNameWithoutExtension = implode('.', $fileNamePartsWithoutExtension);
            
            $imagine = new Imagine();

            // we create the thumnail
            $widthFirst = ModUtil::getVar('MUImage', 'widthFirst');
            $heightFirst = ModUtil::getVar('MUImage', 'heightFirst');
            if ($widthFirst > 0 && $heightFirst > 0) {
                $nameForThumb = $fileNameWithoutExtension . '_tmb.jpg';
                $imagine->open($basePath . $fileName)->thumbnail(new Box($widthFirst, $heightFirst), 'inset')->save($basePath . $nameForThumb);
            }
            // we create the preview
            $widthSecond = ModUtil::getVar('MUImage', 'widthSecond');
            $heightSecond = ModUtil::getVar('MUImage', 'heightSecond');
            if ($widthSecond > 0 && $heightSecond > 0) {
                $nameForThumb = $fileNameWithoutExtension . '_pre.jpg';
                $imagine->open($basePath . $fileName)->thumbnail(new Box($widthSecond, $heightSecond), 'inset')->save($basePath . $nameForThumb);
            }
            // we create the full image
            $widthThird = ModUtil::getVar('MUImage', 'widthThird');
            $heightThird = ModUtil::getVar('MUImage', 'heightThird');
            if ($widthThird > 0 && $heightThird > 0) {
                $nameForThumb = $fileNameWithoutExtension . '_full.jpg';
                $imagine->open($basePath . $fileName)->thumbnail(new Box($widthThird, $heightThird), 'inset')->save($basePath . $nameForThumb);
            }
        }

        // collect data to return
        $result['fileName'] = $fileName;
        $result['metaData'] = $this->readMetaDataForFile($fileName, $basePath . $fileName);

        return $result;
    }


    /**
     * Check if an upload file meets all validation criteria.
     *
     * @param array $file Reference to data of uploaded file.
     *
     * @return boolean true if file is valid else false
     */
    protected function validateFileUpload($objectType, $file, $fieldName)
    {
        $dom = ZLanguage::getModuleDomain('MUImage');

        $result = true;

        // check if a file has been uploaded properly without errors
        if ((!is_array($file)) || (is_array($file) && ($file['error'] != '0'))) {
            if (is_array($file)) {
                return $this->handleError($file);
            }
            LogUtil::registerError(__('Error! No file found.', $dom));
            $result = false;
        }


        if ($fieldName == 'zipUpload') {
            $maxSize = ModUtil::getVar('MUImage', 'zipSize');
        } else {
            $maxSize = ModUtil::getVar('MUImage', 'fileSize');
        }

        if ($maxSize > 0) {

            $fileSize = filesize($file['tmp_name']);

            if ($fileSize > $maxSize) {
                $maxSizeKB = $maxSize / 1024;
                if ($maxSizeKB < 1024) {
                    $maxSizeKB = DataUtil::formatNumber($maxSizeKB);
                    $fileName = $file['name'];
                    if ($fieldName == 'zipUpload') {
                        return LogUtil::registerError(__f('Error! Your file %s is too big. Please keep it smaller than %s kilobytes.', array($fileName, $maxSizeKB), $dom));
                    } else {
                        LogUtil::registerError(__f('Error! Your file %s is too big. Please keep it smaller than %s kilobytes.', array($fileName, $maxSizeKB), $dom));
                        return false;
                    }
                }
                $maxSizeMB = $maxSizeKB / 1024;
                $maxSizeMB = DataUtil::formatNumber($maxSizeMB);
                $fileName = $file['name'];
                if ($fieldName == 'zipUpload') {
                    return LogUtil::registerError(__f('Error! Your file %s is too big. Please keep it smaller than %s megabytes.', array($fileName, $maxSizeKB), $dom));
                } else {
                    LogUtil::registerError(__f('Error! Your file %s is too big. Please keep it smaller than %s megabytes.', array($fileName, $maxSizeKB), $dom));
                    $result = false;
                }
            }
        }

        // extract file extension
        $fileName = $file['name'];
        $extensionarr = explode('.', $fileName);
        $extension = strtolower($extensionarr[count($extensionarr) - 1]);

        // validate extension
        $isValidExtension = $this->isAllowedFileExtension($objectType, $fieldName, $extension);
        if ($isValidExtension === false) {
            LogUtil::registerError(__('Error! This file type is not allowed. Please choose another file format.', $dom));
            $result = false;
             
        }

        // validate image file
        $imgInfo = array();
        $isImage = in_array($extension, $this->imageFileTypes);
        if ($isImage) {
            $imgInfo = getimagesize($file['tmp_name']);
            if (!is_array($imgInfo) || !$imgInfo[0] || !$imgInfo[1]) {
                return LogUtil::registerError(__('Error! This file type seems not to be a valid image.', $dom));
            }
            $requiredWidth = ModUtil::getVar('MUImage', 'minWidth');
            $maxWidth = ModUtil::getVar('MUImage', 'maxWidth');
            $maxHeight = ModUtil::getVar('MUImage', 'maxHeight');
            if ($requiredWidth != '') {
                if ($imgInfo[0] < $requiredWidth) {
                    LogUtil::registerError(__('Sorry! Your picture does not have the required width.', $dom));
                    $url = ModUtil::url('MUImage', 'user', 'view');
                    $result = false;
                }
            }
            if ($maxWidth != '') {
                if ($imgInfo[0] > $maxWidth && ModUtil::getVar('MUImage', 'shrinkPictures') == 0) {
                    LogUtil::registerError(__('Sorry! Your picture is wider than allowed.', $dom));
                    $url = ModUtil::url('MUImage', 'user', 'view');
                    $result = false;
                }
            }
            if ($maxHeight != '') {
                if ($imgInfo[1] > $maxHeight && ModUtil::getVar('MUImage', 'shrinkPictures') == 0) {
                    LogUtil::registerError(__('Sorry! Your picture is higher than allowed.', $dom));
                    $url = ModUtil::url('MUImage', 'user', 'view');
                    $result = false;
                }
            }
        }

        return $result;
    }
    
    /**
     * Read meta data from a certain file.
     *
     * @param string $fileName  Name of file to be processed.
     * @param string $filePath  Path to file to be processed.
     *
     * @return array collected meta data
     */
    public function readMetaDataForFile($fileName, $filePath)
    {
        $meta = array();
        if (empty($fileName)) {
            return $meta;
        }
    
        $extensionarr = explode('.', $fileName);
        $meta = array();
        $meta['extension'] = strtolower($extensionarr[count($extensionarr) - 1]);
        $meta['size'] = filesize($filePath);
        $meta['isImage'] = (in_array($meta['extension'], $this->imageFileTypes) ? true : false);
    
        if (!$meta['isImage']) {
            return $meta;
        }
    
        if ($meta['extension'] == 'swf') {
            $meta['isImage'] = false;
        }
    
        $imgInfo = getimagesize($filePath);
        if (!is_array($imgInfo)) {
            return $meta;
        }
    
        $meta['width'] = $imgInfo[0];
        $meta['height'] = $imgInfo[1];
    
        if ($imgInfo[1] < $imgInfo[0]) {
            $meta['format'] = 'landscape';
        } elseif ($imgInfo[1] > $imgInfo[0]) {
            $meta['format'] = 'portrait';
        } else {
            $meta['format'] = 'square';
        }
        
        if (ModUtil::getVar('MUImage', 'createSeveralPictureSizes')) {
            $fileNameParts = explode('.', $fileName);
            $fileNamePartsWithoutExtension = array_slice($fileNameParts, 0, count($fileNameParts) - 1);
            $fileNameWithoutExtension = implode('.', $fileNamePartsWithoutExtension);
            $meta['filename'] = $fileNameWithoutExtension;
        }
    
        return $meta;
    }

    /**
     * Determines the allowed file extensions for a given object type.
     *
     * @param string $objectType Currently treated entity type.
     * @param string $fieldName  Name of upload field.
     * @param string $extension  Input file extension.
     *
     * @return array the list of allowed file extensions
     */
    protected function isAllowedFileExtension($objectType, $fieldName, $extension)
    {
        $request = new Zikula_Request_Http();
        $func = $request->query->filter('func', 'main', FILTER_SANITIZE_STRING);
        // determine the allowed extensions
        $allowedExtensions = array();
        if ($func == 'edit' || $func == 'multiUpload') {
            switch ($objectType) {
                case 'picture':
                    $allowedExtensions = array('gif', 'jpeg', 'jpg', 'png');
                    break;
            }
        } else {
            switch ($objectType) {
                case 'picture':
                    $allowedExtensions = array('zip');
                    break;
            }
        }
        if (count($allowedExtensions) > 0) {
            if (!in_array($extension, $allowedExtensions)) {
                return false;
            }
        }

        if (in_array($extension, $this->forbiddenFileTypes)) {
            return false;
        }

        return true;
    }
}
